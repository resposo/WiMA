from typing import Iterable
from volatility3.framework import renderers, interfaces
from volatility3.framework.configuration import requirements
from volatility3.framework.interfaces import plugins
from .sessions import Sessions
from volatility3.plugins.windows import pslist, psscan
import logging
from .thrdscan import ThrdScan
from datetime import datetime
vollog = logging.getLogger(__name__)

class HiddenProcesses(plugins.PluginInterface):
    """I Can Find Suspicious process ex : DKOM AND LPE
    If you want LPE process detection, run priviligesmodify first(--privilege)"""
    _required_framework_version = (2, 5, 0)
    _version = (1, 0, 0)

    @classmethod
    def get_requirements(cls) -> Iterable[interfaces.configuration.RequirementInterface]:
        return [
            requirements.TranslationLayerRequirement(
                name='primary',
                description='Memory layer for the kernel',
                architectures=['Intel32', 'Intel64']
            ),
            requirements.SymbolTableRequirement(
                name="nt_symbols", 
                description="Windows kernel symbols"
            ),
            requirements.BooleanRequirement(
                name="privilege", 
                description="Check privileges from systemprivileges_pid.txt(First, run privilegesmodify)",
                optional=True
            ),
            requirements.BooleanRequirement(
                name="PRDS", 
                description="Filter processes based on filtered_pids.txt",
                optional=True
            ),
            requirements.ListRequirement(
                name="pid",
                element_type=int,
                description="Process ID to include (all other processes are excluded)",
                optional=True,
            )
        ]

    def _get_privilege_pids(self):
        try:
            with open("systemprivileges_pid.txt", "r") as f:
                lines = f.readlines()
                privileges = {}
                for line in lines:
                    parts = line.strip().split(", ")
                    pid = int(parts[0].split(":")[1].strip())
                    priv_data = {}
                    for priv in parts[1:]:
                        priv_num = int(priv.split(":")[1].split()[0])
                        attributes = priv.split("[")[1].split("]")[0].split(",") if priv.split("[")[1].split("]")[0].strip() else []
                        priv_data[priv_num] = attributes
                    privileges[pid] = priv_data
                return privileges
        except FileNotFoundError:
            raise Exception("Please run privilegesmodify first and then use --privilege")
        except Exception as e:
            vollog.debug(f"Failed to read systemprivileges_pid.txt: {e}")
            return {}

    def analyze_privileges(self, privilege_data):
        # 1. Check if 7, 20, 29 all keys have empty values
        if all(not privilege_data.get(num) for num in [7, 20, 29]):
            return "Low"
        # 2. Check if 7, 20, 29 all keys have ["Present", "Enabled", "Default"] values or only 20 has it
        if all(privilege_data.get(num, []) == ["Present", "Enabled", "Default"] for num in [7, 20, 29]) or privilege_data.get(20, []) == ["Present", "Enabled", "Default"]:
            return "\033[31m\033[43m High \033[0m"
        # 3. Check if any of the keys 7, 20, 29 have any of the ["Present", "Enabled", "Default"] values
        if any(any(val in privilege_data.get(num, []) for val in ["Present", "Enabled", "Default"]) for num in [7, 20, 29]):
            return "\033[94m Medium \033[0m"

    def _read_filtered_pids(self):
        try:
            with open("filtered_pids.txt", "r") as f:
                return [int(line.strip()) for line in f if line.strip().isdigit()]
        except FileNotFoundError:
            raise Exception("filtered_pids.txt not found. Please ensure the file exists.")
        except Exception as e:
            vollog.debug(f"Failed to read filtered_pids.txt: {e}")
            return []

    def _generator(self):
        psscan_plugin = psscan.PsScan.scan_processes(
            self.context, 
            self.config['primary'], 
            self.config['nt_symbols']
        )

        threadscan_plugin = ThrdScan.scan_threads(
            self.context, 
            self.config['primary'], 
            self.config['nt_symbols']
        )

        pslist_plugin = pslist.PsList.list_processes(
            self.context, 
            self.config['primary'], 
            self.config['nt_symbols'],
        )

        Sessions_plugin_Username = pslist.PsList.list_processes(
            self.context, 
            self.config['primary'], 
            self.config['nt_symbols']
        )

        pslist_processes = {
            p.UniqueProcessId: (
                p.ImageFileName.cast("string", max_length=p.ImageFileName.vol.count, errors="replace"), 
                p.InheritedFromUniqueProcessId
            ) for p in pslist_plugin
        }

        sessions_data = {}
        for proc in Sessions_plugin_Username:
            full_user = Sessions.extract_user_info(proc)
            sessions_data[proc.UniqueProcessId] = full_user

        psscan_processes = {
            p.UniqueProcessId: (
                p.ImageFileName.cast("string", max_length=p.ImageFileName.vol.count, errors="replace"), 
                p.InheritedFromUniqueProcessId, 
                p.get_create_time(),
                p.get_exit_time()
            ) for p in psscan_plugin
        }

        all_process_names = [p[0] for p in pslist_processes.values()] + [p[0] for p in psscan_processes.values()]
        process_name_width = max(len(name) for name in all_process_names)

        thread_processes = [thread.Cid.UniqueProcess for thread in threadscan_plugin]

        privilege_data = self._get_privilege_pids()

        combined_processes = {}
        for pid, (name, ppid) in pslist_processes.items():
            create_time_str = psscan_processes[pid][2].strftime('%Y-%m-%d %H:%M:%S') if pid in psscan_processes and isinstance(psscan_processes[pid][2], datetime) else 'N/A'
            exit_time_str = psscan_processes[pid][3].strftime('%Y-%m-%d %H:%M:%S') if pid in psscan_processes and isinstance(psscan_processes[pid][3], datetime) else 'N/A'

            combined_processes[pid] = {
                'name': name,
                'ppid': ppid,
                'in_pslist': True,
                'in_psscan': pid in psscan_processes,
                'create_time': create_time_str,
                'exit_time': exit_time_str
            }

        for pid, (name, ppid, create_time, exit_time) in psscan_processes.items():
            create_time_str = create_time.strftime('%Y-%m-%d %H:%M:%S') if isinstance(create_time, datetime) else 'N/A'
            exit_time_str = exit_time.strftime('%Y-%m-%d %H:%M:%S') if isinstance(exit_time, datetime) else 'N/A'

            if pid not in combined_processes:
                combined_processes[pid] = {
                    'name': name,
                    'ppid': ppid,
                    'in_pslist': False,
                    'in_psscan': True,
                    'create_time': create_time_str,
                    'exit_time': exit_time_str
                }

        # Check for PRDS option and read the filtered_pids.txt if enabled
        filter_pids = []
        if self.config.get('PRDS', False):
            filter_pids = self._read_filtered_pids()

        # Get user-specified PIDs
        specific_pid = self.config.get('pid', None)
        
        for pid, process_info in combined_processes.items():
            # Skip if specific_pid is set and current PID is not in specific_pid
            if specific_pid and pid not in specific_pid:
                continue

            # Filter based on filtered_pids.txt if PRDS option is enabled
            if filter_pids and pid not in filter_pids:
                continue
            
            full_user = sessions_data.get(pid, 'N/A')
            padded_process_name = process_info['name'].ljust(process_name_width)
            privilege_status = "-"
            if self.config.get('privilege', False):
                privilege_status = "N/A"  # Option provided but no data available, set to "N/A"
                if pid in privilege_data:
                    privilege_status = self.analyze_privileges(privilege_data[pid])

            
            yield (0, (pid, 
                    padded_process_name, 
                    process_info['ppid'], 
                    process_info['in_pslist'], 
                    process_info['in_psscan'], 
                    pid in thread_processes, 
                    process_info['create_time'], 
                    process_info['exit_time'], 
                    full_user, 
                    privilege_status))

    def run(self):
        return renderers.TreeGrid(
            [("PID", int), 
             ("ProcessName", str), 
             ("PPID", int), 
             ("Pslist", bool), 
             ("Psscan", bool), 
             ("Thdscan", bool), 
             ("CreateTime", str), 
             ("ExitTime", str), 
             ("UserName", str),
             ("ProcessPrivilege", str)],  
            self._generator()
        )
