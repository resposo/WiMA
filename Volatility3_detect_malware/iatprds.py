import logging
import hashlib
import io
import pefile
import sqlite3
from volatility3.framework import exceptions, interfaces, renderers
from volatility3.framework.configuration import requirements
from volatility3.plugins.windows import pslist
from volatility3.framework.objects import utility
from volatility3.framework.symbols import intermed
from volatility3.framework.symbols.windows.extensions import pe
from volatility3.framework import constants

# 로거 설정
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CombinedPRDSIAT(interfaces.plugins.PluginInterface):
    _required_framework_version = (2, 0, 0)
    _version = (2, 0, 0)

    @classmethod
    def get_requirements(cls):
        return [
            requirements.ModuleRequirement(name="kernel", description="Windows kernel", architectures=["Intel32", "Intel64"]),
            requirements.ListRequirement(name="pid", element_type=int, description="Process IDs to include", optional=True),
            requirements.IntRequirement(name="search", description="Search for specific PID", optional=True),
        ]

    @classmethod
    def list_processes(cls, context, layer_name, symbol_table, filter_func=lambda _: False):
        kvo = context.layers[layer_name].config["kernel_virtual_offset"]
        ntkrnlmp = context.module(symbol_table, layer_name=layer_name, offset=kvo)
        ps_aph_offset = ntkrnlmp.get_symbol("PsActiveProcessHead").address
        list_entry = ntkrnlmp.object(object_type="_LIST_ENTRY", offset=ps_aph_offset)
        reloff = ntkrnlmp.get_type("_EPROCESS").relative_child_offset("ActiveProcessLinks")

        eproc = ntkrnlmp.object(object_type="_EPROCESS", offset=list_entry.vol.offset - reloff, absolute=True)
        for proc in eproc.ActiveProcessLinks:
            if not filter_func(proc):
                yield proc

    def find_process_name_by_pid(self, context, kernel, pid):
        target_proc = next(filter(lambda p: p.UniqueProcessId == pid, self.list_processes(context, kernel.layer_name, kernel.symbol_table_name)), None)
        if target_proc is not None:
            try:
                return utility.array_to_string(target_proc.ImageFileName)
            except exceptions.InvalidAddressException as e:
                logger.exception(f"Error reading ImageFileName for PID {pid}: {e}")
                return "Error reading ImageFileName"
        return "N/A"

    def find_parent_process_name(self, context, kernel, proc):
        parent_pid = proc.InheritedFromUniqueProcessId
        return self.find_process_name_by_pid(context, kernel, parent_pid)

    def find_exe_path(self, proc):
        try:
            for module in proc.load_order_modules():
                dll_name = module.FullDllName.get_string()
                return dll_name
        except exceptions.InvalidAddressException:
            return "Error reading Executable Path"
        return "N/A"

    def get_dll_details(self, context, proc, kernel):
        dll_names = []
        try:
            proc_layer_name = proc.add_process_layer()
            peb = context.object(kernel.symbol_table_name + constants.BANG + "_PEB", layer_name=proc_layer_name, offset=proc.Peb)
            pe_table_name = intermed.IntermediateSymbolTable.create(context, kernel.symbol_table_name, "windows", "pe", class_types=pe.class_types)
            pe_data = io.BytesIO()
            dos_header = context.object(pe_table_name + constants.BANG + "_IMAGE_DOS_HEADER", offset=peb.ImageBaseAddress, layer_name=proc_layer_name)

            if dos_header.e_magic != 0x5A4D:
                return []

            for offset, data in dos_header.reconstruct():
                pe_data.seek(offset)
                pe_data.write(data)

            pe_obj = pefile.PE(data=pe_data.getvalue(), fast_load=True)
            pe_obj.parse_data_directories([pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_IMPORT"]])

            if hasattr(pe_obj, "DIRECTORY_ENTRY_IMPORT"):
                for entry in pe_obj.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode() if entry.dll else "Unknown"
                    dll_names.append(dll_name)
        except exceptions.PagedInvalidAddressException as e:
            return []  # 페이지 폴트 오류 발생시 빈 리스트 반환
        except (ValueError, exceptions.InvalidAddressException) as e:
            return []
        return dll_names

    def calculate_sha256(self, process_name, exe_path, parent_name, dll_names):
        # 로깅으로 DLL 목록과 기타 정보 출력
        logger.debug(f"Calculating SHA-256 for Process: {process_name}, Executable Path: {exe_path}, Parent Process: {parent_name}, DLLs: {dll_names}")

        if not dll_names:
            return "N/A"  # 빈 DLL 목록인 경우 'N/A' 반환

        # DLL 목록을 오름차순으로 정렬
        sorted_dll_names = sorted(dll_names)

        # 정렬된 DLL 목록을 사용하여 해시 입력 생성
        hash_input = ';'.join([process_name, exe_path, parent_name] + sorted_dll_names)
        return hashlib.sha256(hash_input.encode()).hexdigest()

    def check_sha256_in_db(self, sha256, db_path):
        """ 주어진 SHA256 값이 데이터베이스에 존재하는지 확인하는 함수 """
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM processes WHERE SHA256 = ?", (sha256,))
        result = cursor.fetchone()[0] > 0
        conn.close()
        return result

    def _generator(self):
        db_path = r'C:\Users\user\Desktop\process_dataset\PRDS.db'
        filter_func = pslist.PsList.create_pid_filter(self.config.get("pid", None))
        search_pid = self.config.get("search", None)
        kernel = self.context.modules[self.config["kernel"]]
        procs = self.list_processes(self.context, kernel.layer_name, kernel.symbol_table_name, filter_func)

        sha256_to_pids = {}
        no_hash_proc_group = {}
        proc_details = {}
        processed_pids = set()

        for proc in procs:
            try:
                process_name = utility.array_to_string(proc.ImageFileName)
                parent_name = self.find_parent_process_name(self.context, kernel, proc)
                exe_path = self.find_exe_path(proc)
                dll_names = self.get_dll_details(self.context, proc, kernel)
                


                sha256_hash = "N/A" if not dll_names else self.calculate_sha256(process_name, exe_path, parent_name, dll_names)
                is_detected = "TRUE" if self.check_sha256_in_db(sha256_hash, db_path) else "FALSE"
                proc_details[proc.UniqueProcessId] = (process_name, exe_path, parent_name, sha256_hash, is_detected)

                if sha256_hash == "N/A":
                    key = (process_name, exe_path, parent_name)
                    if key not in no_hash_proc_group:
                        no_hash_proc_group[key] = []
                    no_hash_proc_group[key].append(proc.UniqueProcessId)
                else:
                    if sha256_hash not in sha256_to_pids:
                        sha256_to_pids[sha256_hash] = []
                    sha256_to_pids[sha256_hash].append(proc.UniqueProcessId)

            except (exceptions.PagedInvalidAddressException, exceptions.InvalidAddressException) as e:
                logger.error(f"Error processing process {proc.UniqueProcessId}: {e}")

        # 'Detect' 값에 따라 정렬
        sorted_proc_details = sorted(proc_details.items(), key=lambda x: x[1][4], reverse=True)

        for pid, details in sorted_proc_details:
            if pid in processed_pids:
                continue

            if search_pid is not None and not (pid == search_pid or details[2] == search_pid or str(pid) in sha256_to_pids.get(details[3], [])):
                continue

            sha256_hash = details[3]
            if sha256_hash == "N/A":
                key = (details[0], details[1], details[2])
                same_pids = [str(other_pid) for other_pid in no_hash_proc_group[key] if other_pid != pid]
                processed_pids.update(no_hash_proc_group[key])
            else:
                same_pids = [str(other_pid) for other_pid in sha256_to_pids[sha256_hash] if other_pid != pid]
                processed_pids.update(sha256_to_pids[sha256_hash])
            same_pids_str = ",".join(same_pids)
            yield (0, (pid, details[0], details[1], details[2], sha256_hash, details[4], same_pids_str))

    def run(self):
        return renderers.TreeGrid(
            [
                ("PID", int),
                ("Process_Name", str),
                ("Executable_Path", str),
                ("Parent_Process_Name", str),
                ("SHA-256", str),
                ("Detect", str),
                ("Same PID", str)
            ],
            self._generator()
        )


